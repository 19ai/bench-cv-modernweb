<style media="screen">
	body {
		margin : 0px; 
		overflow: hidden;
	}
	canvas {
		border: none;
		display: block;
	}

</style>
<canvas id="canvas"></canvas>

<!-- vertex shader -->
<script id="2d-vertex-shader" type="x-shader/x-vertex">
	attribute vec2 a_position;
	attribute vec2 a_texCoord;

	uniform vec2 u_resolution;

	varying vec2 v_texCoord;

	void main() {
		// convert the rectangle from pixels to 0.0 to 1.0
		vec2 zeroToOne = a_position / u_resolution;
		
		// convert from 0->1 to 0->2
		vec2 zeroToTwo = zeroToOne * 2.0;
		
		// convert from 0->2 to -1->+1 (clipspace)
		vec2 clipSpace = zeroToTwo - 1.0;
		
		gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
		
		// pass the texCoord to the fragment shader
		// The GPU will interpolate this value between points.
		v_texCoord = a_texCoord;
	}
</script>
<!-- fragment shader -->
<script id="2d-fragment-shader" type="x-shader/x-fragment">
	precision mediump float;

	// our texture
	uniform sampler2D u_image;

	// the texCoords passed in from the vertex shader.
	varying vec2 v_texCoord;

	void main() {
		// vec4 texel = texture2D(u_image, v_texCoord);
		gl_FragColor = texture2D(u_image, v_texCoord).bgra;
	}
</script>
<!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<body>
	
	<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
	<script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-helper.js"></script>
<script>
'use strict';

//////////////////////////////////////////////////////////////////////////////
//		build videoElement
//////////////////////////////////////////////////////////////////////////////
var videoElement = document.createElement('video')
// document.body.appendChild(videoElement)
videoElement.autoplay = true

// https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
var userMediaContraints = {
        // video: true,
        video : {
                width: 640,
                height:480
        }
}
navigator.mediaDevices.getUserMedia(userMediaContraints).then(function(stream){
        videoElement.src = window.URL.createObjectURL(stream);
}).catch(function(error){
	console.assert(false, 'getUserMedia failed due to')
	console.dir(error)
})

//////////////////////////////////////////////////////////////////////////////
//		build canvas
//////////////////////////////////////////////////////////////////////////////

var canvas = document.getElementById('canvas');
canvas.width = window.innerWidth
canvas.height = window.innerHeight
var gl = canvas.getContext('webgl');


webglUtils.resizeCanvasToDisplaySize(gl.canvas);

// Tell WebGL how to convert from clip space to pixels
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

// Clear the canvas
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);



// setup GLSL program
var program = webglUtils.createProgramFromScripts(gl, ['2d-vertex-shader', '2d-fragment-shader']);

// look up where the vertex data needs to go.
var positionLocation = gl.getAttribLocation(program, 'a_position');
var texcoordLocation = gl.getAttribLocation(program, 'a_texCoord');

// Create a buffer to put three 2d clip space points in
var positionBuffer = gl.createBuffer();

// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
// Set a rectangle the same size as the image.
var x1 = 0;
var x2 = 0 + gl.canvas.width;
var y1 = 0;
var y2 = 0 + gl.canvas.height;
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
	x1, y1,
	x2, y1,
	x1, y2,
	x1, y2,
	x2, y1,
	x2, y2,
]), gl.STATIC_DRAW);

// provide texture coordinates for the rectangle.
var texcoordBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
	0.0,  0.0,
	1.0,  0.0,
	0.0,  1.0,
	0.0,  1.0,
	1.0,  0.0,
	1.0,  1.0,
]), gl.STATIC_DRAW);

// Create a texture.
var texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);

// Set the parameters so we can render any size image.
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

// Upload the image into the texture.
// gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

// lookup uniforms
var resolutionLocation = gl.getUniformLocation(program, 'u_resolution');

// Tell it to use our program (pair of shaders)
gl.useProgram(program);

// Turn on the position attribute
gl.enableVertexAttribArray(positionLocation);

// Bind the position buffer.
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

// Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
var size = 2;          // 2 components per iteration
var type = gl.FLOAT;   // the data is 32bit floats
var normalize = false; // don't normalize the data
var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
var offset = 0;        // start at the beginning of the buffer
gl.vertexAttribPointer(
	positionLocation, size, type, normalize, stride, offset
)

// Turn on the teccord attribute
gl.enableVertexAttribArray(texcoordLocation);

// Bind the position buffer.
gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

// Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
var size = 2;          // 2 components per iteration
var type = gl.FLOAT;   // the data is 32bit floats
var normalize = false; // don't normalize the data
var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
var offset = 0;        // start at the beginning of the buffer
gl.vertexAttribPointer(
	texcoordLocation, size, type, normalize, stride, offset
)

// set the resolution
gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);


requestAnimationFrame(function callback(){
	render(videoElement)
	
	requestAnimationFrame(callback)	
})

function render(image) {
	// update texImage2D
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	
	// Draw the rectangle.
	var primitiveType = gl.TRIANGLES;
	var offset = 0;
	var count = 6;
	gl.drawArrays(primitiveType, offset, count);
}


</script>
</body>
